import GhostAdminAPI from '@tryghost/admin-api';
import OpenAI from 'openai';
import { config } from 'dotenv';
import * as readline from 'readline';
import { createHmac } from 'crypto';
import { readFileSync, writeFileSync, mkdirSync } from 'fs';
import { resolve, join } from 'path';
config();

// Ghost Admin API JWT 签名
function signJWT(id, secret) {
  const now = Math.floor(Date.now() / 1000);
  const header = Buffer.from(JSON.stringify({ alg: 'HS256', typ: 'JWT', kid: id })).toString('base64url');
  const payload = Buffer.from(JSON.stringify({ iat: now, exp: now + 300, aud: '/admin/' })).toString('base64url');
  const sig = createHmac('sha256', Buffer.from(secret, 'hex')).update(`${header}.${payload}`).digest('base64url');
  return `${header}.${payload}.${sig}`;
}

const ghost = new GhostAdminAPI({
  url: process.env.GHOST_URL,
  key: process.env.GHOST_ADMIN_API_KEY,
  version: 'v5.0'
});

const ai = new OpenAI({
  baseURL: process.env.OPENAI_BASE_URL,
  apiKey: process.env.OPENAI_API_KEY,
});

function ask(question) {
  const rl = readline.createInterface({ input: process.stdin, output: process.stdout });
  return new Promise(resolve => rl.question(question, ans => { rl.close(); resolve(ans.trim()); }));
}

async function fetchSite() {
  const [id, secret] = process.env.GHOST_ADMIN_API_KEY.split(':');
  const res = await fetch(`${process.env.GHOST_URL}/ghost/api/admin/site/`, {
    headers: { Authorization: `Ghost ${signJWT(id, secret)}` }
  });
  const data = await res.json();
  return {
    title: data.site?.title || '',
    description: data.site?.description || '',
    url: process.env.GHOST_URL,
  };
}

function savePreview(slug, html, prompt = '') {
  const dir = resolve('./previews');
  mkdirSync(dir, { recursive: true });
  const file = join(dir, `${slug}.html`);
  const promptComment = prompt
    ? `<!--\n  GENERATED BY: xiaomengtao generate-ui.js\n  DATE: ${new Date().toISOString()}\n  PROMPT:\n${prompt.split('\n').map(l => '  ' + l).join('\n')}\n-->\n`
    : '';
  const full = `<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1.0"><title>Preview: ${slug}</title></head><body>${promptComment}${html}</body></html>`;
  writeFileSync(file, full, 'utf-8');
  return file;
}

async function writeBack(post, html) {
  await ghost.posts.edit({
    id: post.id,
    updated_at: post.updated_at,
    codeinjection_head: html,
    custom_template: 'custom-artshow',
  });
}

// ── 模式 A：AI 生成 → 本地预览 → 确认回写 ──
async function modeGenerate(slug, site, post) {
  const styleHint = await askStyleWithRecommend(post, '[3/6]');
  console.log('\n[4/6] 构造 prompt...');
  const prompt = buildPrompt(post, site, styleHint);

  console.log('[5/6] 调用 AI 生成 HTML...');
  const completion = await ai.chat.completions.create({
    model: process.env.OPENAI_MODEL || 'gpt-4o',
    max_tokens: 8192,
    messages: [{ role: 'user', content: prompt }]
  });
  const raw = completion.choices[0].message.content;
  const html = raw.replace(/^```html\n?/, '').replace(/\n?```$/, '').trim();

  const previewFile = savePreview(slug, html, prompt);
  console.log(`\n[6/6] 预览文件已生成：`);
  console.log(`      ${previewFile}`);
  console.log(`      用浏览器打开确认效果\n`);

  const confirm = await ask('确认回写到 Ghost？(y/N): ');
  if (confirm.toLowerCase() === 'y') {
    await writeBack(post, html);
    console.log(`\n✓ 已回写: ${post.title}`);
    console.log(`  预览: ${site.url}/${post.slug}/`);
  } else {
    console.log('\n已取消。HTML 保留在 previews/ 目录，可修改后用 --file 模式回写。');
  }
}

function savePrompt(slug, prompt) {
  const dir = resolve('./previews');
  mkdirSync(dir, { recursive: true });
  const file = join(dir, `${slug}.prompt.md`);
  writeFileSync(file, prompt, 'utf-8');
  return file;
}

// ── 模式 C：只生成 prompt，保存为 md 文件 ──
async function modePromptOnly(slug, site, post) {
  const styleHint = await askStyleWithRecommend(post, '[3/4]');
  console.log('\n[4/4] 构造 prompt...');
  const prompt = buildPrompt(post, site, styleHint);
  const file = savePrompt(slug, prompt);
  console.log(`\n✓ Prompt 已保存：`);
  console.log(`  ${file}`);
}
async function modeFile(slug, site, post, filePath) {
  const html = readFileSync(resolve(filePath), 'utf-8')
    // 如果是完整 HTML 文件，提取 body 内容
    .replace(/^[\s\S]*<body[^>]*>/i, '')
    .replace(/<\/body>[\s\S]*$/i, '')
    .trim();

  console.log(`[3/3] 回写到 Ghost...`);
  await writeBack(post, html);
  console.log(`\n✓ 已回写: ${post.title}`);
  console.log(`  预览: ${site.url}/${post.slug}/`);
}

async function main() {
  const args = process.argv.slice(2);
  const slug = args[0];
  const fileIdx = args.indexOf('--file');
  const filePath = fileIdx !== -1 ? args[fileIdx + 1] : null;
  const promptOnly = args.includes('--prompt-only');

  if (!slug) {
    console.log('用法:');
    console.log('  node generate-ui.js <slug>                    AI 生成，本地预览后确认回写');
    console.log('  node generate-ui.js <slug> --file <path>      直接上传本地 HTML 回写');
    console.log('  node generate-ui.js <slug> --prompt-only      只生成 prompt，保存为 md 文件');
    process.exit(1);
  }

  const steps = promptOnly ? 4 : filePath ? 3 : 6;
  console.log(`[1/${steps}] 拉取站点信息...`);
  const site = await fetchSite();
  console.log(`      站点: ${site.title} (${site.url})`);

  console.log(`[2/${steps}] 拉取文章: ${slug}`);
  const post = await ghost.posts.read({ slug }, { formats: ['html'], include: 'tags,authors' });
  console.log(`      标题: "${post.title}"\n`);

  if (promptOnly) {
    await modePromptOnly(slug, site, post);
  } else if (filePath) {
    await modeFile(slug, site, post, filePath);
  } else {
    await modeGenerate(slug, site, post);
  }
}

async function recommendStyle(post) {
  const tags = post.tags?.filter(t => !t.name.startsWith('#')).map(t => t.name).join(', ') || '无';
  const prompt = `你是一个前端设计顾问。请根据以下博客文章的内容，推荐一个最合适的整体视觉风格。

文章标题：${post.title}
文章分类：${tags}
文章摘要：${post.custom_excerpt || post.excerpt || ''}
文章正文（前500字）：
${(post.html || '').replace(/<[^>]+>/g, '').slice(0, 500)}

请按以下格式输出，不要输出任何其他内容：

【风格分析】
<一两句话，解释为什么推荐这个风格>

【推荐关键词】
<逗号分隔的风格关键词，可直接用于描述整体视觉风格，不涉及具体布局>`;

  const completion = await ai.chat.completions.create({
    model: process.env.OPENAI_MODEL || 'gpt-4o',
    max_tokens: 300,
    messages: [{ role: 'user', content: prompt }]
  });
  const content = completion.choices?.[0]?.message?.content;
  if (!content) return '';
  return content.trim();
}

async function askStyleWithRecommend(post, stepLabel) {
  console.log(`${stepLabel} 分析文章风格...`);
  let recommendation = '';
  try {
    recommendation = await recommendStyle(post);
  } catch (e) {
    console.warn('  风格推荐失败，跳过：', e.message);
  }

  // 提取【推荐关键词】行作为默认值
  const keywordsMatch = recommendation.match(/【推荐关键词】\s*\n([\s\S]*?)(?:\n【|$)/);
  const defaultKeywords = keywordsMatch ? keywordsMatch[1].trim() : '';

  console.log('\n' + '─'.repeat(50));
  console.log(recommendation);
  console.log('─'.repeat(50) + '\n');

  const input = await ask(`风格描述（直接回车使用推荐风格，输入内容则覆盖）: `);
  return input || defaultKeywords;
}

function buildPrompt(post, site, styleHint) {
  const tags = post.tags?.filter(t => !t.name.startsWith('#')).map(t => t.name).join(', ') || '无';
  const defaultStyle = `设计感强、艺术感强、扁平风格、信息密度高、大胆的排版——大字标题、强对比色、克制的留白、网格感布局`;
  const styleDesc = styleHint
    ? `用户指定风格：${styleHint}\n同时保持整体基调：${defaultStyle}`
    : `默认风格：${defaultStyle}`;

  return `你是一个前端艺术家，专门为博客文章创作独特的视觉页面。

## 站点信息（重要，所有链接必须基于此）
- 站点名称：${site.title}
- 站点域名：${site.url}
- 站点简介：${site.description}
- 首页链接：${site.url}/
- 当前文章链接：${site.url}/${post.slug}/

## 文章信息
- 标题：${post.title}
- 分类：${tags}
- 摘要：${post.custom_excerpt || post.excerpt || ''}
- 正文（HTML）：
${post.html}

## 风格要求
${styleDesc}

## 输出要求
1. 只输出 <style> 块 + HTML 结构，不要 <!DOCTYPE>、<html>、<head>、<body> 标签
2. 所有链接必须使用真实域名 ${site.url}，禁止使用 example.com、blog.domain.com 等占位域名
3. 风格与文章情绪/主题深度结合——技术文章可用终端风格，情感文章可用诗意排版，旅行文章可用明信片风格等
4. 正文内容创意编排，可以有分栏、浮动引用、大字排版，不要简单线性堆叠
5. 必须包含返回首页链接：<a href="${site.url}/">← 返回展览大厅</a>
6. 字体使用 Google Fonts，在 <style> 里用 @import 引入
7. 页面完整可读，移动端友好
8. 只输出代码，不要任何解释文字

## 正文完整性要求（最重要）
- 文章正文必须完整保留，一字不漏，不得删减、概括、改写、替换任何内容
- 不得用"..."、"（此处省略）"、"（内容继续）"等方式省略任何段落
- 创意排版只是改变视觉呈现方式，文字内容本身必须与原文完全一致
- 如果正文很长，页面可以很长，不要为了"好看"而牺牲完整性`;
}

main().catch(err => {
  console.error('错误:', err.message);
  process.exit(1);
});
